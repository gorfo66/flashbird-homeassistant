name: Auto Semantic Version Tag

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  tag_repo:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # get tags

      - name: Fetch tags
        run: git fetch --tags

      - name: Determine next version
        id: version
        run: |
          # Get latest tag or use 0.0.0 if none exist
          latest=$(git tag --sort=-v:refname | head -n 1)
          if [ -z "$latest" ]; then
            latest="0.0.0"
          fi
          echo "Latest tag: $latest"

          # Extract numbers
          MAJOR=$(echo "$latest" | cut -d. -f1)
          MINOR=$(echo "$latest" | cut -d. -f2)
          PATCH=$(echo "$latest" | cut -d. -f3)

          # Get commit message
          msg=$(git log -1 --pretty=%B)
          echo "Commit message: $msg"

          # Choose bump type using Conventional Commits
          if echo "$msg" | grep -qE "BREAKING CHANGE|!:"; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$msg" | grep -qE "^feat(\(.+\))?: "; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif echo "$msg" | grep -qE "^fix(\(.+\))?: "; then
            PATCH=$((PATCH + 1))
          else
            # default to patch update
            PATCH=$((PATCH + 1))
          fi

          new="$MAJOR.$MINOR.$PATCH"
          echo "New tag will be: $new"
          echo "tag=$new" >> $GITHUB_OUTPUT

      - name: Create and push tag
        run: |
          git tag ${{ steps.version.outputs.tag }}
          git push origin ${{ steps.version.outputs.tag }}